### selection sort
1. 找出每个数组中最小的，放到前面
2. 依次循环，直到排完
3. O(N^2)

### insertion sort
1. 从index 1开始，和之前的序列进行比较，找到其位置，后面的向后推一位
2. 插入其位置，依次循环，直到排完
3. O(N^2)
4. 优点，额外空间只需要一个tmp， O(1)

### shell sort
1. 隔开N个数字进行先插入排序，使得每个隔开多少的序列是有序的
2. 将N减小进行shell sort，最后得到排完序的序列
3. 优点，可以减少插入排序中的各种元素向后推一位的问题
4. 使用3x+1的间隔，为O(N^3/2)

### shuffle sort
1. 给每张牌生成随机数，然后用他们的value进行排序
2. Knuth shuffle 从第一张牌开始，在0-max之前随机一个数，然后进行交换

### Merge sort
1. sort左半边，sort右半边，然后比较两个半边的头元素进行合并
2. 优点：算法复杂度低 O(nLg(n)), 大数据量时比O(n^2)的算法优势明显
3. 缺点: 小规模时候，如2， 4 这种数量级的时候需要拷贝数据到额外数组中，比较费时，可在切到小数据量的时候使用insert sort进行优化, 同时由于需要一个额外空间进行merge操作，空间复杂度O(n)
4. 在右半边头元素和左半边尾元素满足排序条件时，可以直接return，无需进行归并操作(优化点)

### Bottom up merge sort
1. merge和普通的mergesort一样，从2->4->8->16这样涨上去，其中分别按照这样的size进行分组merge
2. 和普通的merge sort不一样的点是，merge sort由于是递归实现，所以是左半边先排完序，然后右半边排完序，然后合并，bottom up merge sort是按照size，每个这个size的小组先是有序的，然后size*2后再把两个有序的子数据合并。

